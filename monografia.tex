\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{palatino}
\usepackage {graphicx}
\usepackage{babel}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage {fancyvrb}

\makeatletter
\makeatother

\begin{document}
\autor{Alexandre Michetti Manduca \hspace{2.3cm} nUsp: 4890832 \\ Filipe Del Nero Grillo \hspace{4cm} nUsp: 5378140}


\titulo{Relatório do projeto final da disciplina de Hipermídia}


\instituicao{Instituto de Ciências Matemáticas e de Computação \par Universidade
de São Paulo \par ICMC - USP}


\local{São Carlos - SP, Brasil}


\data{12 de maio de 2011}

\capa

\tableofcontents{}

\chapter{Introdução}\label{cap:introducao}

	Com a evolução evolução da internet, as tecnologias que a compõem também estão em constante desenvolvimento. Em meados de 2004 surgia o termo \textit{Web 2.0}, que foi cunhado para se referir a uma nova geração de serviços que surgiam utilizando a \textit{Web} como plataforma. Uma das características marcantes dessa nova geração de serviços era o fato se buscar que as aplicações \textit{Web} possuíssem uma interação com o usuário mais próxima da experiência de se utilizar um aplicativo \textit{desktop}.
	
	Uma das técnicas utilizadas para melhorar a interação com usuário é conhecida como AJAX (\textit{Assynchronous JavaScript and XML}), que será explicado adiante na seção \ref{sec:ajax}.

	Seguindo esta evolução, no início de 2008 a W3C (\textit{World Wide Web Consortium})\footnote{W3C é um consórcio de empresas de tecnologia que tem por objetivo desenvolver padrões para criação e interpretação de conteúdo para a \textit{Web}} anunciou a primeira especificação do HTML5, uma nova versão da linguagem de marcação que é utilizada para formatar e organizar o conteúdo que está disponível na internet. O HTML5 está previsto para ser finalizado no ano de 2012 e traz alterações muito interessantes no sentido de aproximar ainda mais a internet do comportamento de aplicações \textit{Desktop}. Dentre as novidades do HTML5 podemos destacar:
	
	\begin{itemize}
		\item Novas API's para uso de gráficos;
		\item Melhora no uso de multimídia sem necessidade de \textit{softwares} de terceiros;
		\item Aprimoramento de uso \textit{off-line};
		\item Melhoria na depuração de erros;
		\item API para uso de canais de comunicação bidirecional (Websocket).
	\end{itemize}
	
	A \textit{Web} vem sendo escolhida como plataforma de desenvolvimento e distribuição de uma gama cada vez maior de aplicações. Sistemas altamente interativos, que enviam dados para os usuários em tempo real ou mesmo que permitem que diversos usuários interajam em tempo real são cada vez mais comuns, como por exemplo o Twitter\footnote{http://www.twitter.com} que mostra as atualizações dos seus amigos quase que instantâneamente, Foursquare\footnote{https://foursquare.com/} que mostra os \textit{check-ins} dos seus amigos quase na hora em que acontecem, entre outros.
	
	O Websocket foi desenvolvido para que se melhore ainda mais a comunicação entre o cliente e o servidor para aplicações de tempo real. O Websocket será explicado na seção \ref{sec:websockets}

\section{AJAX}\label{sec:ajax}

	AJAX, sigla para \textit{Assynchronous JavaScript and XML}, é na verdade um conjunto de tecnologias já existentes mas utilizadas de uma forma nova, tornando possível uma aplicação desenvolvida em JavaScript que esteja rodando no cliente se comunicar com o servidor de forma assíncrona. Dessa forma, o usuário pode continuar trabalhando e interagindo com a página, enquanto dados são enviados e requisitados do servidor.
		
	Uma aplicação AJAX elimina a natureza interrompida de interação na \textit{web} introduzindo uma camada intermediária, a aplicação AJAX, entre o usuário e o servidor. Essa camada torna a velocidade de resposta da aplicação mais rápida. Ao invés de carregar uma página web, no início da sessão o navegador carrega a aplicação codificada em JavaScript e ela fica responsável por renderizar a interface e fazer a comunicação com o servidor de acordo com as necessidades do usuário.
		
	Como a aplicação AJAX está sempre ativa no \textit{browser} do cliente, a interação é contínua, os dados serão carregados a medida que forem necessários sem impedir o usuário de continuar interagindo com a aplicação.
	
\section{Websockets}\label{sec:websockets}

	As tecnologias utilizadas na \textit{Web} atualmente, mesmo o AJAX, são construídas sobre o paradigma \textit{request}/\textit{response} imposto pelo HTTP. Nesse paradigma, os clientes iniciam as interações com o sistema, o que não é adequado para a obtenção de informações em tempo real, já que o servidor recebe primeiro as informações.

	Para tentar contornar esses problemas, uma série de mecanismos construídos sobre a tecnologia AJAX e HTTP foram desenvolvidos, de modo a permitir a obtenção de dados em tempo real pelos clientes, ou pelo menos passar essa sensação para o usuário. Apenas para exemplificar, um mecanismo com esse fim conhecido como \textit{Long Polling}, funciona mantendo conexões do cliente abertas até que um dado esteja disponível no servidor. Quando esse dado fica disponível e é enviado para o cliente, um novo \textit{request} é feito, e sua conexão não é fechada até que um novo dados esteja disponível. O ciclo assim se repete passando a ilusão de que o servidor esta enviando em tempo real os dados para o cliente.

	Contudo, todos esses mecanismos tem um problema, que é o \textit{overhead} causado pelo HTTP. Por exemplo, cada \textit{request}/\textit{response} HTTP carrega uma série de informações de cabeçalho que podem tornar a latência dessas aplicações muito grande, tornando algumas aplicações inviáveis. Pense como exemplo, um jogo \textit{multiplayer} de tiro que rode em um \textit{browser}.

	Visando esse tipo de aplicação, a W3C está padronizando uma nova API, que visa trazer conexões bidirecionais e \textit{full-duplex} para os navegadores e servidores \textit{Web} através de Sockets TCP. O \textit{handshake} do WebSocket é feito via HTTP, que permite em sua versão 1.1 especificar cabeçalhos com essa finalidade. No entanto, a especificação WebSocket ainda tem algumas problemas até poder ser adotada de fato na \textit{Web}, como o fato de que muitos navegadores, servidores de aplicação, servidores \textit{proxy} e \textit{firewalls} não estão preparados para ele.


\section{Objetivos do trabalho}\label{sec:objetivos}

	O objetivo deste trabalho é realizar uma análise comparativa entre as tecnologias AJAX e Websocket em uma aplicação que utiliza comunicação intensamente. Para tal serão desenvolvidas duas aplicações de bate-papo simples e construídas especificamente para o propósito desta análise.

	\begin{figure} [!ht]
	\begin{center}
	\includegraphics[width=1\textwidth]{images/chat_websocket.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia Websocket.}
	\label{fig:chat_socket}
	
	\includegraphics[width=1\textwidth]{images/chat_ajax.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia AJAX.}
	\label{fig:chat_ajax}
	\end{center}
	\end{figure}

	Ambas as aplicações foram desenvolvidas com o objetivo de se manter o mesmo fluxo de interação e funcionarem de maneira exatamente igual aos olhos de um usuário leigo. Nas Figuras \ref{fig:chat_socket} e \ref{fig:chat_ajax}, podemos ver as \textit{interfaces} das aplicações implementadas com Websocket a AJAX, respectivamente. Com exceção da palavra "ajax" no título da página, nenhuma outra distinção é visível para o usuário.


\chapter{Preparação do experimento}\label{cap:preparacao}

	Para a execução do experimento, foram construídas duas aplicações de chat, uma baseada em AJAX e outra em WebSockets, e também dois \textit{scripts} para simularem múltiplos clientes enviando e recebendo mensagens ao mesmo tempo no servidor.

	Tirando a parte visual da aplicação, as implementações do lado do servidor foram feitas de maneira a seguirem uma implementação usual de AJAX e WebSockets. Ou seja, não ouve preocupação em manter semelhanças nas implementações, e sim em manter a mesma funcionalidade, com o modelo usual de desenvolvimento em cada tecnologia.

	Na aplicação WebSockets, cada mensagem é repassada para todos os outros usuários no instante em que chega ao servidor. Enquanto que na implementação com AJAX, cada mensagem que chega é armazenada em um array em memória, e a cada 0,5 segundos cada cliente faz uma requisição para obter a lista de mensagens do servidor, passando como parâmetro a última mensagem que recebeu.

	Dois servidores Ubuntu foram então preparados em uma solução de Cloud Computing, sendo que um executaria o servidor do chat e o outro o script para simular os clientes, de modo que um não interferisse nas medições do outro. Tanto o servidor quanto o \textit{script} imprimiam linhas de log, que foram coletados para a geração das comparações e gráficos utilizados neste relatório.

\section{Tecnologias utilizadas}

	Este trabalho se baseia na comparação entre as tecnologias AJAX e WebSockets. Como WebSocket é uma tecnologia ainda em desenvolvimento, existem poucas linguagens, navegadores e servidores de aplicação que a suportam. Com essas restrições, decidimos por utilizar o framework Node.js\footnote{http://www.nodejs.org}, que suporta nativamente AJAX e WebSockets através do módulo Socket.IO\footnote{http://socket.io}.

	Node.js é um framework para IO (\textit{Input/Output}) assíncrono, cuja linguagem de programação é o JavaScript, mas que é executado no servidor ao invés de em um navegador. JavaScript é ideal para IO assíncrono, já que é uma linguagem baseada em eventos e seu modelo de programação é não bloqueante. O motor JavaScript utilizado pelo Node.js é o Google V8\footnote{http://code.google.com/p/v8/}, que é muito rápido, e compila o JavaScript para código nativo antes de sua execução.

	A aplicação \textit{Web} foi construída utilizando o framework de aplicações \textit{Web} para Node.js chamado Express\footnote{http://expressjs.com/}, juntamente com a linguagem de templates Jade. No lado do cliente, foram utilizados JQuery\footnote{http://jquery.com}, JQuery UI\footnote{http://jqueryui.com/} e o 52Framework\footnote{http://www.52framework.com/} para montagem do \textit{layout} das páginas.

	O navegador utilizado para os testes da aplicação \textit{Web} foi o Google Chrome 11. Os servidores utilizados para execução dos testes de performance foram máquinas virtuais Ubuntu 10.10 no Rackspace Cloud.\footnote{http://www.rackspace.com/cloud/}

	Para a execução dos testes de performance, foram implementados \textit{scripts} em Node.js para as duas tecnologias. Com WebSockets, foi utilizado o módulo websocket-client, enquanto que para a implementação AJAX foram utilizados os recursos HTTP nativos do Node.js.
	

\section{Ambiente}

	Para a realização dos testes foram criadas duas máquinas virtuais no Rackspace Cloud, sendo que uma máquina foi utilizada para executar a parte servidora da aplicação, e a outra, o script de \textit{benchmark}. As duas máquinas tinham a mesma configuração, sendo ela:

	\begin{itemize}
		\item \textbf{Sistema Operacional:} Ubuntu 10.10 (Maverick Meerkat)
		\item \textbf{CPU:} Quad-Core AMD Opteron(tm) Processor 2374 HE, 2,2 Ghz, 512 Cache
		\item \textbf{Memória:} 256 Mb
	\end{itemize}	

      Por ser uma solução de \textit{Cloud Computing}, não temos algumas informações como velocidade da rede entre as duas máquinas e velocidade dos discos rígidos. Além disso, as máquinas virtuais não utilizam o poder total dos processadores. Quanto maior o plano contratado, maior o uso que se pode fazer do processador.
	
\section{Dados a serem coletados}

	Durante a execução do experimentos, dados serão coletados tanto nos clientes quanto nos servidores. Em ambos os casos os dados são coletados através de impressões na tela com padrão CSV (\textit{Comma Separated Values}) que são redirecionadas para um arquivo de texto no momento da execução.
	
	Os servidores coletam dados em intervalos de 1 em 1 segundo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,Número de usuários,Consumo de memória,Consumo de CPU,Total de mensagens,
    Número de mensagens desde o último log"
	\end{Verbatim}
	}
	
	Formato:
	
	\begin{enumerate}
		\item \textbf{Timestamp:} HH:MM:SS:000, Hora, Minutos, Segundos e Milisegundos.
		\item \textbf{Número de usuários:} O número de usuários conectados à sala de bate-papo no momento da impressão da linha.
		\item \textbf{Consumo de memória:} A porcentagem de memória que o processo servidor está utilizando no momento da impressão. 
		\item \textbf{Consumo de CPU:} A porcentagem da CPU que está sendo utilizada pelo servidor no momento da impressão.
		\item \textbf{Total de mensagens:} Soma de todas as comunicações realizadas com todos os clientes
		\item \textbf{Número de mensagens desde o último log: } Número de comunicações com os clientes desde a impressão da linha de log anterior.
	\end{enumerate}
	
	Os clientes coletam dados a cada comunicação com o servidor, seja ela recebendo ou enviando mensagens no bate-papo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,ID do usuário,Operação,Número de usuários,Tamanho da mensagem"
	\end{Verbatim}
	}
	
	\begin{enumerate}
		\item \textbf{Timestamp:} Igual ao servidor: HH:MM:SS:000 - Hora, Minutos, Segundos e Milisegundos
		\item \textbf{ID do usuário:} Qual o usuário que enviou a mensagem
		\item \textbf{Operação:} Qual o tipo da mensagem: RECEIVE quando o cliente está recebendo mensagens do servidor e SEND quando o cliente está enviando mensagens para o servidor.
		\item \textbf{Número de usuários:} O número de usuários conectados à sala de bate-papo no momento da impressão da linha.
		\item \textbf{Tamanho da mensagem:} O tamanho total da mensagem referente à essa linha de log. No caso da implementação com AJAX inclui a soma dos cabeçalhos e conteúdos do \textit{request} e \textit{response} e no caso da implementação com Websockets conta o o conteúdo e dados utilizados pelo protocolo de comunicação do Socket.IO.
	\end{enumerate}
	
	Os dados relativos a entrada e saída da sala de bate-papo são desconsideradas neste experimento.

\chapter{Execução}\label{cap:execução}

	Os \textit{scripts} foram executados de modo a simularem 40 clientes simultâneos, gerando uma mensagem por segundo, em um total de 200 mensagens cada. Lembrando que na aplicação AJAX, além do envio da mensagem, cada cliente fazia a requisição para novas mensagens a cada 0,5 segundos. Além disso, os 40 usuários foram inseridos a uma taxa de 1 novo usuário por segundo, até atingir os 40 usuários.

	O número de 40 usuários foi escolhido, pois com mais de 50 usuários a implementação do script de benchmark com WebSockets e mostrou instável, devido ao grande número de mensagens enviadas, e pelo fato de que o script necessitava fazer umarshalling de cada mensagem para ver do que se travatava e então calcular os dados relevantes. Nós também optamos por adicionar 1 usuário a cada 1 segundo para não causar uma carga excessiva e repentina no sevidor. Além disso, executamos o script de benchmark em uma máquina diferente da máquina servidora, de modo que um processo não interferisse no outro.

	Os experimentos foram então executados, sendo que cada um levou cerca de 4 minutos para terminar. Os arquivos de log dos servidores e dos clientes foram coletados e utilizados para a análise dos dados e para geração dos gráficos. No entanto, para gerar gráficos satisfatoriamente, foi necessário selecionar  uma amostra, já que esses os experimentos geraram uma quantidade muito grande de dados, principalmente na implementação com WebSockets. Assim, na implementação com WebSockets, 1 em cada 200 linhas dos arquivos de log foi utilizada na geração dos gráficos, enquanto que na implementação com Ajax, que teve menos registros nos logs, 1 em cada 20 linhas do arquivo de log foi utilizada.


\chapter{Dados obtidos}\label{cap:dados obtidos}

	A partir da execução dos experimentos e dos 4 arquivos coletados  obtivemos os seguintes dados.
	
	\section{Processo servidor}
	
		No processo servidor, foram analisadas o consumo dos processos e a quantidade de comunicação entre cliente e servidor. A seguir temos alguns gráficos que foram gerados a partir dos dados obtidos. 
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/processo_server_ajax.png}
		\caption {Dados de consumo para o processo servidor com a implementação AJAX. (a) - Número de usuários conectados no servidor ao longo do tempo. (b) Consumo de memória do processo servidor "\%"\ no tempo. (c) - Consumo de CPU do processo servidor em "\%"\ no tempo.}
		\label{fig:proc_server_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/processo_server_socket.png}
		\caption {Dados de consumo para o processo servidor com a implementação Websocket. (a) - Número de usuários conectados no servidor ao longo do tempo. (b) Consumo de memória do processo servidor "\%"\ no tempo. (c) - Consumo de CPU do processo servidor em "\%"\ no tempo.}
		\label{fig:proc_server_socket}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/mensages_ajax.png}
		\caption {Quantidade de comunicação entre clientes e servidor na implementação com AJAX. (a) - Quantidade de comunicações por segundo ao longo do tempo da execução do experimento. (b) - Quantidade de usuários conectados no servidor ao longo do tempo.}
		\label{fig:msg_server_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/mensages_socket.png}
		\caption {Quantidade de comunicação entre clientes e servidor na implementação com Websocket. (a) - Quantidade de comunicações por segundo ao longo do tempo da execução do experimento. (b) - Quantidade de usuários conectados no servidor ao longo do tempo.}
		\label{fig:msg_server_socket}
		\end{center}
		\end{figure}
		
	\section{Processo cliente}
	
		Nos processos cliente foi analisado principalmente o tamanho de cada comunicação entre cliente e servidor. O dados da Tabela \ref{tab:dados} foram extraídos a partir do conjunto total de dados, enquanto os gráficos das Figuras \ref{fig:msg_client_ajax} e \ref{fig:msg_client_socket} foram gerados a partir de amostras em função do número muito grande de dados.
	
		
\begin{table}					
\begin{center}
	\begin{tabular}{ | l | c | c |  }
	\hline
	\textbf{Dado} & \textbf{AJAX} & \textbf{Websocket} \\
	 \hline
	 \hline
	 
	 Tempo inicial:  & 21:39:24 & 21:35:33 \\
	\hline
	Tempo final:  & 21:43:26 & 21:39:56 \\
	\hline
	Duração do experimento: & 4m 2s (242s) & 4m 22s (263s \\
	\hline
	\hline
	Número de operações SEND:  & 8000 & 8000 \\
	\hline
	Número de operações RECEIVE:  & 16000 & 274115 \\
	\hline
	Soma dos tamanhos dos SEND:  & 6178000 (bytes) & 910255(bytes) \\
	\hline
	Soma dos tamanhos dos RECEIVE:  & 41394106 (bytes) & 37250287 (bytes)\\
	\hline
	Média de tamanho dos SEND:  & 772,25 (bytes) & 113,78 (bytes) \\
	\hline
	Média de tamanho dos RECEIVE:  & 2587,13 (bytes) & 135,89 (bytes) \\
	\hline
	Variância dos tamanhos dos SEND:  & 842,02 & 865,14 \\
	\hline
	Variância dos tamanhos dos RECEIVE:  & 158728,67 & 838,24 \\
	\hline
	Desvio padrão dos tamanhos dos SEND:  & 29,02 & 29,41\\
	\hline
	Desvio padrão dos tamanhos dos RECEIVE:  & 398,41 & 28,95 \\
	\hline
	\hline
	Total de dados trafegados:  & 47572106 (bytes) & 38160542 (bytes) \\
	\hline
	Taxa de dados:  & 196578,95 (bytes/s) & 145097,12 (bytes/s) \\
	\hline
	\end{tabular}
	
	\caption{Dados coletados a partir de todo conjunto de dados do processo cliente implementado com AJAX}
	\label{tab:dados}
\end{center}
\end{table}


		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/tamanho_mensagens_ajax.png}
		\caption {Tamanho total das comunicações na implementação AJAX. (a) - Tamanho das mensages (bytes) tanto de \textit{sends} quanto de \textit{requests} ao longo do tempo. (b) - Número de usuários conectados no servidor ao longo do tempo. Este gráfico foi gerado a partir de uma amostra da massa de dados.}
		\label{fig:msg_client_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/tamanho_mensagens_socket.png}
		\caption {Tamanho total das comunicações na implementação com Websocket. (a) - Tamanho das mensages (bytes) tanto de \textit{sends} quanto de \textit{requests} ao longo do tempo. (b) - Número de usuários conectados no servidor ao longo do tempo. Este gráfico foi gerado a partir de uma amostra da massa de dados.}
		\label{fig:msg_client_socket}
		\end{center}
		\end{figure}

\chapter{Resultados obtidos}\label{cap:conclusao}

	A partir dos dados coletados, podemos verificar que ambas as tecnologias tem vantagens e desvantagens. A tecnologia WebSocket proporciona a transmissão de mensagens entre os usuários do chat em tempo real, mas ao mesmo tempo, gera uma quantidade muito maior de mensagens quando comparado a uma implementação comum em AJAX, como pode ser visto na Tabela \ref{tab:dados} onde temos que o \textit{script} da implementação AJAX teve 16000 mensagens de RECEIVE enquanto o \textit{script} da implementação Websocket tragefou  274115 mensagens deste mesmo tipo, muito embora cada mensagem tenha um tamanho menor nesta última implementação.
	
	Isso se deve principalmente ao tamanho dos cabeçalhos que são transmitidos em cada requisição AJAX. Na Tabela \ref{tab:dados} nota-se que enquanto uma mensagem de SEND da implementação AJAX possui em média 772,25 bytes, as mensagens de SEND da implementação Websocket possuem em média 113,78 bytes. Ambas possuem uma variação pequena que pode ser confirmado pelos seus desvios padrão 29,02 e 29,41 respectivamente e que pode ser explicada pelo tamanho do conteúdo randômico que foi utilizado nas implementações dos \textit{scripts} de teste.
	
	Essa grande quantidade de mensagens tornou a implementação em WebSockets como está praticamente inviável, uma vez que o próprio \textit{script} de \textit{benchmark} teve trabalho para tratar todas as mensagens que chegavam. O servidor no entanto, não foi muito afetado por essa carga, uma vez que ele simplesmente despacha as mensagens, sem ter que processá-las. Essa característica fez com que o servidor em WebSockets utiliza-se menos memória quanto comparado a implementação em Ajax, que precisa guardar as mensagens em memória até que os usuários faziam uma requisição Ajax para obtê-las. Em relação ao uso de CPU a implementação com Websockets foi consideravelmente maior, embora os experimentos não tivessem objetivo de testar os limites de carga de cada implementação, notamos pela comparação das curvas (c) nas Figuras \ref{fig:proc_server_ajax} e \ref{fig:proc_server_socket} que a diferença foi substancial, embora mais testes sejam necessários para se estabeler até que ponto este consumo afetar o servidor com o crescimento do número de usuários e/ou mensagens.

	Notamos que a implementação em Ajax como está, utilizando um \textit{array} de mensagens, que é consultado pelos usuários de tempo em tempo, cria um mecanismo de \textit{buffer/cache}, que melhora o uso do sistema trazendo vantagens quando comparados a implementação com WebSockets. Em função deste efeito de \textit{buffer} nota-se através dos dados coletados que o tamanho das mensagens de RECEIVE virão muito no implementação com AJAX enquanto a implementação com AJAX essas mensagens possuem um tamanho mais bem comportado. Além disso, um tempo de 0,5 segundos para a obtenção das mensagens não é tão rápido quando na versão em WebSockets, mas esse tempo pode é bastante aceitável para aplicações como um bate-papo.
	
	Seria diferente se estivéssemos comparando um jogo on-line onde diversos jogadores podem interagir uns com os outros, neste caso a implementação Websockets traria uma experiência de uso muito melhor do que a AJAX.

	Por outro lado, a implementação em WebSockets poderia ser modificada, de modo a guardar as mensagens para cada usuário por um tempo, e estão despachá-las em lote para os usuários, em um mecanismo parecido com o Ajax. Teoricamente, isso melhoraria o desempenho da aplicação WebSockets, tirando ainda o \textit{overhead} do HTTP, como latência e cabeçalhos desnecessários. Isso no entanto, eliminaria uma das principais vantagens desta API que é a comunicação em tempo real.
	
	
	XXX FALAR SOBRE O TAMANHO TRAFEGADO E COMO ISSO SERIA DIFERENTE SE UTILIZASSEMOS MENSAGENS MAIORES XXX
	
	É importante salientar que a tecnologia de Websockets não foi criada com a intenção de substituir as técnicas AJAX, e sim para explorar alguns de seus pontos fracos. Portanto o que deve ser feito quando se planeja construir uma aplicação é ponderar sobre as vantagens e desvantagens de cada uma em relação as necessidades específicas do seu projeto.

	
	
%\bibliographystyle{abnt-num}
%\bibliography{monografia}

%  \anexo
%  \chapter{Glossário}
%  Teste de apêndice


\end{document}