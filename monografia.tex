\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{palatino}
\usepackage {graphicx}
\usepackage{babel}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage {fancyvrb}

\makeatletter
\makeatother

\begin{document}
\autor{Alexandre Michetti Manduca \hspace{2.3cm} nUsp: 4890832 \\ Filipe Del Nero Grillo \hspace{4cm} nUsp: 5378140}


\titulo{Relatório do projeto final da disciplina de Hipermídia}


\instituicao{Instituto de Ciências Matemáticas e de Computação \par Universidade
de São Paulo \par ICMC - USP}


\local{São Carlos - SP, Brasil}


\data{12 de maio de 2011}

\capa

\tableofcontents{}

\chapter{Introdução}\label{cap:introducao}

	Com a evolução evolução da internet, as tecnologias que a compõem também estão em constante desenvolvimento. Em meados de 2004 surgia o termo \textit{Web 2.0}, que foi cunhado para se referir a uma nova geração de serviços que surgiam utilizando a \textit{Web} como plataforma. Uma das características marcantes dessa nova geração de serviços era o fato se buscar que as aplicações \textit{Web} possuíssem uma interação com o usuário mais próxima da experiência de se utilizar um aplicativo \textit{desktop}.
	
	Uma das técnicas utilizadas para melhorar a interação com usuário é conhecida como AJAX (\textit{Assynchronous JavaScript and XML}), que será explicado adiante na seção \ref{sec:ajax}.

	Seguindo esta evolução, no início de 2008 a W3C (\textit{World Wide Web Consortium})\footnote{W3C é um consórcio de empresas de tecnologia que tem por objetivo desenvolver padrões para criação e interpretação de conteúdo para a \textit{Web}} anunciou a primeira especificação do HTML5, uma nova versão da linguagem de marcação que é utilizada para formatar e organizar o conteúdo que está disponível na internet. O HTML5 está previsto para ser finalizado no ano de 2012 e traz alterações muito interessantes no sentido de aproximar ainda mais a internet do comportamento de aplicações \textit{Desktop}. Dentre as novidades do HTML5 podemos destacar:
	
	\begin{itemize}
		\item Novas API's para uso de gráficos;
		\item Melhora no uso de multimídia sem necessidade de \textit{softwares} de terceiros;
		\item Aprimoramento de uso \textit{off-line};
		\item Melhoria na depuração de erros;
		\item API para uso de canais de comunicação bidirecional (Websocket).
	\end{itemize}
	
	A \textit{Web} vem sendo escolhida como plataforma de desenvolvimento e distribuição de uma gama cada vez maior de aplicações. Sistemas altamente interativos, que enviam dados para os usuários em tempo real ou mesmo que permitem que diversos usuários interajam em tempo real são cada vez mais comuns, como por exemplo o Twitter\footnote{http://www.twitter.com} que mostra as atualizações dos seus amigos quase que instantâneamente, Foursquare\footnote{https://foursquare.com/} que mostra os \textit{check-ins} dos seus amigos quase na hora em que acontecem, entre outros.
	
	O Websocket foi desenvolvido para que se melhore ainda mais a comunicação entre o cliente e o servidor para aplicações de tempo real. O Websocket será explicado na seção \ref{sec:websockets}

\section{AJAX}\label{sec:ajax}

	AJAX, sigla para \textit{Assynchronous JavaScript and XML}, é na verdade um conjunto de tecnologias já existentes mas utilizadas de uma forma nova, tornando possível uma aplicação desenvolvida em JavaScript que esteja rodando no cliente se comunicar com o servidor de forma assíncrona. Dessa forma, o usuário pode continuar trabalhando e interagindo com a página, enquanto dados são enviados e requisitados do servidor.
		
	Uma aplicação AJAX elimina a natureza interrompida de interação na \textit{web} introduzindo uma camada intermediária, a aplicação AJAX, entre o usuário e o servidor. Essa camada torna a velocidade de resposta da aplicação mais rápida. Ao invés de carregar uma página web, no início da sessão o navegador carrega a aplicação codificada em JavaScript e ela fica responsável por renderizar a interface e fazer a comunicação com o servidor de acordo com as necessidades do usuário.
		
	Como a aplicação AJAX está sempre ativa no \textit{browser} do cliente, a interação é contínua, os dados serão carregados a medida que forem necessários sem impedir o usuário de continuar interagindo com a aplicação.
	
\section{Websockets}\label{sec:websockets}

	As tecnologias utilizadas na \textit{Web} atualmente, mesmo o AJAX, são construídas sobre o paradigma \textit{request}/\textit{response} imposto pelo HTTP. Nesse paradigma, os clientes iniciam as interações com o sistema, o que não é adequado para a obtenção de informações em tempo real, já que o servidor recebe primeiro as informações.

	Para tentar contornar esses problemas, uma série de mecanismos construídos sobre a tecnologia AJAX e HTTP foram desenvolvidos, de modo a permitir a obtenção de dados em tempo real pelos clientes, ou pelo menos passar essa sensação para o usuário. Apenas para exemplificar, um mecanismo com esse fim conhecido como \textit{Long Polling}, funciona mantendo conexões do cliente abertas até que um dado esteja disponível no servidor. Quando esse dado fica disponível e é enviado para o cliente, um novo \textit{request} é feito, e sua conexão não é fechada até que um novo dados esteja disponível. O ciclo assim se repete passando a ilusão de que o servidor esta enviando em tempo real os dados para o cliente.

	Contudo, todos esses mecanismos tem um problema, que é o \textit{overhead} causado pelo HTTP. Por exemplo, cada \textit{request}/\textit{response} HTTP carrega uma série de informações de cabeçalho que podem tornar a latência dessas aplicações muito grande, tornando algumas aplicações inviáveis. Pense como exemplo, um jogo \textit{multiplayer} de tiro que rode em um \textit{browser}.

	Visando esse tipo de aplicação, a W3C está padronizando uma nova API, que visa trazer conexões bidirecionais e \textit{full-duplex} para os navegadores e servidores \textit{Web} através de Sockets TCP. O \textit{handshake} do WebSocket é feito via HTTP, que permite em sua versão 1.1 especificar cabeçalhos com essa finalidade. No entanto, a especificação WebSocket ainda tem algumas problemas até poder ser adotada de fato na \textit{Web}, como o fato de que muitos navegadores, servidores de aplicação, servidores \textit{proxy} e \textit{firewalls} não estão preparados para ele.


\section{Objetivos do trabalho}\label{sec:objetivos}

	O objetivo deste trabalho é realizar uma análise comparativa entre as tecnologias AJAX e Websocket em uma aplicação que utiliza comunicação intensamente. Para tal serão desenvolvidas duas aplicações de bate-papo simples e construídas especificamente para o propósito desta análise.

	\begin{figure} [!ht]
	\begin{center}
	\includegraphics[width=1\textwidth]{images/chat_websocket.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia Websocket.}
	\label{fig:chat_socket}
	
	\includegraphics[width=1\textwidth]{images/chat_ajax.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia AJAX.}
	\label{fig:chat_ajax}
	\end{center}
	\end{figure}

	Ambas as aplicações foram desenvolvidas com o objetivo de se manter o mesmo fluxo de interação e funcionarem de maneira exatamente igual aos olhos de um usuário leigo. Nas Figuras \ref{fig:chat_socket} e \ref{fig:chat_ajax}, podemos ver as \textit{interfaces} das aplicações implementadas com Websocket a AJAX, respectivamente. Com exceção da palavra "ajax" no título da página, nenhuma outra distinção é visível para o usuário.


\chapter{Preparação do experimento}\label{cap:preparacao}

	Para a execução do experimento, foram construídas duas aplicações de chat, uma baseada em AJAX e outra em WebSockets, e também dois \textit{scripts} para simularem múltiplos clientes enviando e recebendo mensagens ao mesmo tempo no servidor.

	Tirando a parte visual da aplicação, as implementações do lado do servidor foram feitas de maneira a seguirem uma implementação usual de AJAX e WebSockets. Ou seja, não ouve preocupação em manter semelhanças nas implementações, e sim em manter a mesma funcionalidade, com o modelo usual de desenvolvimento em cada tecnologia.

	Na aplicação WebSockets, cada mensagem é repassada para todos os outros usuários no instante em que chega ao servidor. Enquanto que na implementação com AJAX, cada mensagem que chega é armazenada em um array em memória, e a cada 0,5 segundos cada cliente faz uma requisição para obter a lista de mensagens do servidor, passando como parâmetro a última mensagem que recebeu.

	Dois servidores Ubuntu foram então preparados em uma solução de Cloud Computing, sendo que um executaria o servidor do chat e o outro o script para simular os clientes, de modo que um não interferisse nas medições do outro. Tanto o servidor quanto o \textit{script} imprimiam linhas de log, que foram coletados para a geração das comparações e gráficos utilizados neste relatório.

\section{Tecnologias utilizadas}

	Este trabalho se baseia na comparação entre as tecnologias AJAX e WebSockets. Como WebSocket é uma tecnologia ainda em desenvolvimento, existem poucas linguagens, navegadores e servidores de aplicação que a suportam. Com essas restrições, decidimos por utilizar o framework Node.js, que suporta nativamente AJAX e WebSockets através do módulo Socket.IO.

	Node.js é um framework para IO assincrono, cuja linguagem de programação é o Javascript, mas que é executado no servidor ao invés de em um navegador. JavaScript é ideal para IO assíncrono, já que é uma linguagem baseada em eventos e seu modelo de programação é não bloqueante. O motor JavaScript utilizado pelo Node.js é o Google V8, que é muito rápido, e compila o JavaScript para código nativo antes de sua execução.

	A aplicação \textit{Web} foi construida utilizando o framework de aplicações \textit{Web} para Node.js chamado Express, juntamente com a linguagem de templates Jade. No lado do cliente, foram utilizados JQuery, JQuery UI e o 52Framework para montagem do \textit{layout} das páginas.

	O navegador utilizado para os testes da aplicação \textit{Web} foi o Google Chrome 11. Os servidores utilizados para execução dos testes de performance foram máquinas virtuais Ubuntu 10.10 no Rackspace Cloud.

	Para a execução dos testes de performance, foram implementados \textit{scripts} em Node.js para as duas tecnologias. Com WebSockets, foi utilizado o módulo websocket-client, enquanto que para a implementação AJAX foram utilizados os recursos HTTP nativos do Node.JS.
	

\section{Ambiente}

	Para a realização dos testes foram criadas duas máquinas virtuais no Rackspace Cloud, sendo que uma máquina foi utilizada para executar a parte servidora da aplicação, e a outra, o script de benchmark. As duas máquinas tinham a mesma configuração, sendo ela:

	\begin{itemize}
		\item Sistema Operacional: Ubuntu 10.10 (Maverick Meerkat)
		\item CPU: Quad-Core AMD Opteron(tm) Processor 2374 HE, 2,2 Ghz, 512 Cache
		\item Memória: 256 Mb
	\end{itemize}	

      Por ser uma solução de Cloud Computing, não temos algumas informações como velocidade da rede entre as duas máquinas e velocidade dos discos rígidos. Além disso, as máquinas virtuais não utilizam o poder total dos processadores. Quanto maior o plano contratado, maior o uso que se pode fazer do processador.
	
\section{Dados a serem coletados}

	Durante a execução do experimentos, dados serão coletados tanto nos clientes quanto nos servidores. Em ambos os casos os dados são coletados através de impressões na tela com padrão CSV (\textit{Comma Separated Values}) que são redirecionadas para um arquivo de texto no momento da execução.
	
	Os servidores coletam dados em intervalos de 1 em 1 segundo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,Número de usuários,Consumo de memória,Consumo de CPU,Total de mensagens,
    Número de mensagens desde o último log"
	\end{Verbatim}
	}
	
	Formato:
	
	\begin{enumerate}
		\item \textbf{Timestamp:} HH:MM:SS:000, Hora, Minutos, Segundos e Milisegundos.
		\item \textbf{Número de usuários:} O número de usuários conectados à sala de bate-papo no momento da impressão da linha.
		\item \textbf{Consumo de memória:} A porcentagem de memória que o processo servidor está utilizando no momento da impressão. 
		\item \textbf{Consumo de CPU:} A porcentagem da CPU que está sendo utilizada pelo servidor no momento da impressão.
		\item \textbf{Total de mensagens:} Soma de todas as comunicações realizadas com todos os clientes
		\item \textbf{Número de mensagens desde o último log: } Número de comunicações com os clientes desde a impressão da linha de log anterior.
	\end{enumerate}
	
	Os clientes coletam dados a cada comunicação com o servidor, seja ela recebendo ou enviando mensagens no bate-papo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,ID do usuário,Operação,Número de usuários,Tamanho da mensagem"
	\end{Verbatim}
	}
	
	\begin{enumerate}
		\item \textbf{Timestamp:} Igual ao servidor: HH:MM:SS:000 - Hora, Minutos, Segundos e Milisegundos
		\item \textbf{ID do usuário:} Qual o usuário que enviou a mensagem
		\item \textbf{Operação:} Qual o tipo da mensagem: RECEIVE quando o cliente está recebendo mensagens do servidor e SEND quando o cliente está enviando mensagens para o servidor.
		\item \textbf{Número de usuários:} O número de usuários conectados à sala de bate-papo no momento da impressão da linha.
		\item \textbf{Tamanho da mensagem:} O tamanho total da mensagem referente à essa linha de log. No caso da implementação com AJAX inclui a soma dos cabeçalhos e conteúdos do \textit{request} e \textit{response} e no caso da implementação com Websockets conta o o conteúdo e dados utilizados pelo protocolo de comunicação do Socket.IO.
	\end{enumerate}
	
	Os dados relativos a entrada e saída da sala de bate-papo são desconsideradas neste experimento.

\chapter{Execução}\label{cap:execução}

	Os \textit{scripts} foram executados de modo a simularem 40 clientes simultâneos, gerando uma mensagem por segundo, em um total de 200 mensagens cada. Lembrando que na aplicação AJAX, além do envio da mensagem, cada cliente fazia a requisição para novas mensagens a cada 0,5 segundo. Além disso, os 40 usuários foram inseridos a uma taxa de 1 novo usuário por segundo, até atingir os 40 usuários.

	Os experimentos foram então executados, sendo que cada um levou cerca de 4 minutos para terminarem. Os arquivos de log dos servidores e dos clientes foram coletados e utilizados para a análise dos dados e para geração dos gráficos. Foi necessário colher uma amostra dos logs dos 	clientes, já que esses geraram uma quantidade muito grande de dados, principalmente a implementação com WebSockets.
	
	%XXX Michetti, a amostragem só foi utilizada para geração dos gráficos :D, as médias e tamanhos daquele XLS foram tiradas do conjunto completo, eles não fariam sentidos se fossem tirados da amostra. XXX


\chapter{Dados obtidos}\label{cap:dados obtidos}

	A partir da execução dos experimentos e dos 4 arquivos coletados  obtivemos os seguintes dados.
	
	\section{Processo servidor}
	
		No processo servidor, foram analisadas o consumo dos processos e a quantidade de comunicação entre cliente e servidor. A tabela \ref{tab:xxx} mostra alguns dados extraídos 
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/processo_server_ajax.png}
		\caption {Dados de consumo para o processo servidor com a implementação AJAX. (a) - Número de usuários conectados no servidor ao longo do tempo. (b) Consumo de memória do processo servidor "\%"\ no tempo. (c) - Consumo de CPU do processo servidor em "\%"\ no tempo.}
		\label{fig:proc_server_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/processo_server_socket.png}
		\caption {Dados de consumo para o processo servidor com a implementação Websocket. (a) - Número de usuários conectados no servidor ao longo do tempo. (b) Consumo de memória do processo servidor "\%"\ no tempo. (c) - Consumo de CPU do processo servidor em "\%"\ no tempo.}
		\label{fig:proc_server_socket}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/mensages_ajax.png}
		\caption {Quantidade de comunicação entre clientes e servidor na implementação com AJAX. (a) - Quantidade de comunicações por segundo ao longo do tempo da execução do experimento. (b) - Quantidade de usuários conectados no servidor ao longo do tempo.}
		\label{fig:msg_server_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/mensages_socket.png}
		\caption {Quantidade de comunicação entre clientes e servidor na implementação com Websocket. (a) - Quantidade de comunicações por segundo ao longo do tempo da execução do experimento. (b) - Quantidade de usuários conectados no servidor ao longo do tempo.}
		\label{fig:msg_server_socket}
		\end{center}
		\end{figure}
		
	\section{Processo cliente}
	
		Nos processos cliente foi analisado principalmente o tamanho de cada comunicação entre cliente e servidor. O dados da Tabela \ref{tab:dados} foram extraídos a partir do conjunto total de dados, enquanto os gráficos das Figuras \ref{fig:msg_client_ajax} e \ref{fig:msg_client_socket} foram gerados a partir de amostras em função do número muito grande de dados.
	
		
\begin{table}					
\begin{center}
	\begin{tabular}{ | l | c | c |  }
	\hline
	\textbf{Dado} & \textbf{AJAX} & \textbf{Websocket} \\
	 \hline
	 \hline
	 
	 Tempo inicial:  & 21:39:24 & 21:35:33 \\
	\hline
	Tempo final:  & 21:43:26 & 21:39:56 \\
	\hline
	Duração do experimento: & 4m 2s (242s) & 4m 22s (263s \\
	\hline
	\hline
	Número de operações SEND:  & 8000 & 8000 \\
	\hline
	Número de operações RECEIVE:  & 16000 & 274115 \\
	\hline
	Soma dos tamanhos dos SEND:  & 6178000 (bytes) & 910255(bytes) \\
	\hline
	Soma dos tamanhos dos RECEIVE:  & 41394106 (bytes) & 37250287 (bytes)\\
	\hline
	Média de tamanho dos SEND:  & 772,25 (bytes) & 113,78 (bytes) \\
	\hline
	Média de tamanho dos RECEIVE:  & 2587,13 (bytes) & 135,89 (bytes) \\
	\hline
	Variância dos tamanhos dos SEND:  & 842,02 & 865,14 \\
	\hline
	Variância dos tamanhos dos RECEIVE:  & 158728,67 & 838,24 \\
	\hline
	Desvio padrão dos tamanhos dos SEND:  & 29,02 & 29,41\\
	\hline
	Desvio padrão dos tamanhos dos RECEIVE:  & 398,41 & 28,95 \\
	\hline
	\hline
	Total de dados trafegados:  & 47572106 (bytes) & 38160542 (bytes) \\
	\hline
	Taxa de dados:  & 196578,95 (bytes/s) & 145097,12 (bytes/s) \\
	\hline
	\end{tabular}
	
	\caption{Dados coletados a partir de todo conjunto de dados do processo cliente implementado com AJAX}
	\label{tab:dados}
\end{center}
\end{table}


		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/tamanho_mensagens_ajax.png}
		\caption {Tamanho total das comunicações na implementação AJAX. (a) - Tamanho das mensages (bytes) tanto de \textit{sends} quanto de \textit{requests} ao longo do tempo. (b) - Número de usuários conectados no servidor ao longo do tempo. Este gráfico foi gerado a partir de uma amostra da massa de dados.}
		\label{fig:msg_client_ajax}
		\end{center}
		\end{figure}
		
		\begin{figure} [!ht]
		\begin{center}
		\includegraphics[width=1\textwidth]{images/tamanho_mensagens_socket.png}
		\caption {Tamanho total das comunicações na implementação com Websocket. (a) - Tamanho das mensages (bytes) tanto de \textit{sends} quanto de \textit{requests} ao longo do tempo. (b) - Número de usuários conectados no servidor ao longo do tempo. Este gráfico foi gerado a partir de uma amostra da massa de dados.}
		\label{fig:msg_client_socket}
		\end{center}
		\end{figure}

\chapter{Resultados obtidos}\label{cap:conclusao}

	texto - Criei um novo capitulo para mostrar os dados obtidos e pensei em deixar na conclusão apenas um texto bem sucinto tirando com as conclusões que tiramos dos dados da seção anterior

	A partir dos dados coletados, podemos verificar que ambas as tecnologias tem vantagens e desvantagens. A tecnologia WebSocket proporciona a transmissão de mensagens entre os usuários do chat em tempo real, mas ao mesmo tempo, gera uma quantidade muito maior delas quando comparado a uma implementação comum em ajax, embora cada mensagem tenha um tamanho menor.

	Essa grande quantidade de mensagens tornou a implementação em WebSockets como está inviável, uma vez que o próprio script de benchmark não conseguia tratar todas as mensagens que chegavam. O servidor no entanto, não foi muito afetado por essa carga, uma vez que ele simplesmente despacha as mensagens, sem ter que processa-las. Essa característica fez com que o servidor em WebSockets utiliza-se menos memória quanto comparado a implementação em Ajax, que precisá guardar as mensagens em memória até que os usuários fazam uma requisição Ajax para obte-las. No entanto, o uso de CPU com WebSockets foi maior.

	Notamos que a implementação em Ajax como está, utilizando um array de mensagens, que é consultado pelos usuários de tempo em tempo, cria um mecanismo de buffer/cache, que melhora o uso do sistema trazendo vantagens quando comparados a implementação com WebSockets. Além disso, um tmepo de 0,5 segundos para a obtenção das mensagens não é tão rápido quando na versão em WebSockets, mas esse tempo pode ser considerado aceitável para aplicações de chat.

	Por outor lado, a implementação em WebSockets poderia ser modificada, de modo a guardar as mensagens para cada usuário por um tempo, e estão despachá-las em lote para os usuários, em um mecanismo parecido com o Ajax. Teoricamente, isso melhoraria o desepenho da aplicação WebSockets, tirando ainda o overhead do HTTP, como latencia e cabeçalhos desnecessários. Isso no entanto, diminuiria a velocidade com que os usuários recebem as mensagens.
	
	
%\bibliographystyle{abnt-num}
%\bibliography{monografia}

%  \anexo
%  \chapter{Glossário}
%  Teste de apêndice


\end{document}