\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{palatino}
\usepackage {graphicx}
\usepackage{babel}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage {fancyvrb}

\makeatletter
\makeatother

\begin{document}
\autor{Alexandre Michetti Manduca \hspace{2.3cm} nUsp: 4890832 \\ Filipe Del Nero Grillo \hspace{4cm} nUsp: 5378140}


\titulo{Relatório do projeto final da disciplina de Hipermídia}


\instituicao{Instituto de Ciências Matemáticas e de Computação \par Universidade
de São Paulo \par ICMC - USP}


\local{São Carlos - SP, Brasil}


\data{12 de maio de 2011}

\capa

\tableofcontents{}

\chapter{Introdução}\label{cap:introducao}

	Com a evolução evolução da internet, as tecnologias que a compõem também estão em constante evolução. Em meados de 2004 surgia o termo \textit{Web 2.0}, que foi cunhado para se referir a uma nova geração de serviços que surgiam utilizando a \textit{Web} como plataforma. Uma das características marcantes dessa nova geração doe serviços era o fato se buscar que as aplicações web possuíssem uma interação com o usuário mais próxima da experiência de se utilizar um aplicativo \textit{desktop}.
	
	Uma das técnicas utilizadas para melhorar a interação com usuário é conhecida como AJAX (\textit{Assynchronous JavaScript and XML}), que será explicado adiante na seção \ref{sec:ajax}.

	Seguindo esta evolução, no início de 2008 a W3C (\textit{World Wide Web Consortium})\footnote{W3C é um consórcio de empresas de tecnologia que tem por objetivo desenvolver padrões para criação e interpretação de conteúdo para a \textit{Web}} anunciou a primeira especificação do HTML5, uma nova versão da linguagem de marcação que é utilizada para formatar e organizar o conteúdo que está disponível na internet. O HTML5 está previsto para ser finalizado em 2012 e traz alterações muito interessantes no sentido de aproximar ainda mais a internet do comportamento de aplicações \textit{Desktop}. Dentre as novidades do HTML podemos destacar:
	
	\begin{itemize}
		\item Novas API's para uso de gráficos
		\item Melhora no uso de multimídia sem necessidade de \textit{softwares} de terceiros.
		\item Aprimoramento de uso \textit{off-line}
		\item Melhoria na depuração de erros
		\item API para uso de canais de comunicação bidirecional (Websocket)
	\end{itemize}
	
	O Websocket foi desenvolvido para que se melhore a comunicação no sentido servidor-cliente pois até então as especificações do HTML somente previam que os clientes sempre iniciavam a comunicação. O Websocket será explicado na seção \ref{sec:websockets}

\section{AJAX}\label{sec:ajax}

	texto
	
\section{Websockets}\label{sec:websockets}

	A Web vem sendo escolhida como plataforma de desenvolvimento e distribuição de uma gama cada vez maior de aplicações. Sistemas altamente interativos, que enviam dados para os usuários em tempo real ou mesmo que permitem que diversos usuários interajam em tempo real são cada vez mais comuns, como por exemplo o Twitter que mostra as atualizações dos seus amigos quase que instantaneamente, Foursquare que mostra os checkins dos seus amigos quase na hora em que acontecem, entre outros.

	As tecnologias utilizadas na Web atualmente, mesmo o AJAX, são construídas sobre o paradigma request/response imposto pelo HTTP. Nesse paradigma, os clientes iniciam as interações com o sistema, o que não é adequado para a obtenção de informações em tempo real, ja que o servidor recebe primeiro as informações.

	Para tentar contornar esses problemas, uma série de mecanismos construídos sobre a tecnologia AJAX e HTTP foram desenvolvidos, de modo a permitir a obtenção de dados em tempo real pelos clientes, ou pelo menos passar essa sensação para o usuário. Apenas para exemplificar, um mecanismo com esse fim conhecido como Long Polling, funciona mantedo conexões do cliente abertas até que um dado esteja disponível no servidor. Quando esse dado fica disponível e é enviado para o cliente, um novo request é feito, e sua conexão não é fechada até que um novo dados esteja disponível. O ciclo assim se repete passando a iluzão de que o servidor esta enviando em tempo real os dados para o cliente.

	Contudo, todos esses mecanismos tem um problema, que é o overhead causado pelo HTTP. Por exemplo, cada request/response HTTP carrega uma série de informações de cabeçalho que podem tornar a latência dessas aplicações muito grande, tornando algumas aplicações inviáveis. Pense como exemplo, um jogo multiplayer de tiro que rode em um browser.

	Visando esse tipo de aplicação, a W3C está padronizando uma nova API, que visa trazer conexões bidirecionais e full-duplex para os navegadores e servidores Web através de Sockets TCP. O handshake do WebSocket é feito via HTTP, que permite em sua versão 1.1 especificar cabeçalhos com essa finalidade. No entanto, a especificação WebSocket ainda tem algumas problemas até poder ser adotada de fato na Web, como o fato de que muitos navegadores, servidores de aplicação, servidores proxy e firewalls não estão preparados para ele.


\section{Objetivos do trabalho}\label{sec:objetivos}

	O objetivo deste trabalho é realizar uma análise comparativa entre as técnologias AJAX e Websocket em uma aplicação que utiliza comunicação intensamente. Para tal serão duas aplicações de bate-papo simples e construídas especificamente para o propósito desta análise.

	\begin{figure} [!ht]
	\begin{center}
	\includegraphics[width=1\textwidth]{images/chat_websocket.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia Websocket.}
	\label{fig:chat_socket}
	
	\includegraphics[width=1\textwidth]{images/chat_ajax.png}
	\caption {Interface do bate-papo desenvolvido com a tecnologia AJAX.}
	\label{fig:chat_ajax}
	\end{center}
	\end{figure}

	Ambas as aplicações foram desenvolvidas com o objetivo de se manter o mesmo fluxo de interação e funcionarem de maneira exatamente igual aos olhos de um usuário leigo.


\chapter{Preparação do experimento}\label{cap:preparacao}

	Para a execução do experimento, foram construídas duas aplicações de chat, uma baseada em Ajax e outra em WebSockets, e também dois scripts para simularem múltiplos clientes enviando e recebendo mensagens ao mesmo tempo no servidor.

	Tirando a parte visual da aplicação, as implementações do lado do servidor foram feitas de maneira a seguirem uma implementação usual de Ajax e WebSockets. Ou seja, não ouve preocupação em manter semelhanças nas implementações, e sim em manter a mesma funcionalidade, com o modelo usual de desenvolvimento em cada tecnologia.

	Na aplicação WebSockets, cada mensagem é repassada para todos os outros usuários no instante em que chega ao servidor. Enquanto que na implementação com Ajax, cada mensagem que chega é armazenada em um array em memória, e a cada 0,5 segundos cada cliente faz uma requisição para obter a lista de mensagens do servidor, passando como parametro a última mensagem que recebeu.

	Dois servidores Ubuntu foram então preparados em uma solução de Cloud Computing, sendo que um executaria o servidor do chat e o outro o script para simular os clientes, de modo que um não interferice nas medições do outro. Tanto o servidor quanto o script imprimiam linhas de log, que foram coletados para a geração das comparações e gráficos utilizados neste relatório.

\section{Tecnologias utilizadas}

	Este trabalho se baseia na comparação entre as tecnologias Ajax e WebSockets. Como WebSocket é uma tecnologia ainda em desenvolvimento, existem poucas linguagens, navegadores e servidores de aplicaçao que a suportam. Com essas restrições, decidimos por utilizar o framework Node.js, que suporta nativamente Ajax e WebSockets através do módulo Socket.IO.

	Node.js é um framework para IO assincrono, cuja linguagem de programação é o Javascript, mas que é executado no servidor ao invés de em um navegador. JavaScript é ideal para IO assincrono, ja que é uma linguagem baseada em eventos e seu modelo de programação é não bloqueante. O motor JavaScript utilizado pelo Node.js é o Google V8, que é muito rápido, e compila o JavaScript para código nativo antes de sua execução.

	A aplicação Web foi construida utilizando o framework de aplicações Web para Node.js chamado Express, juntamente com a linguagem de templates Jade. No lado do cliente, foram utilizados JQuery, JQuery UI e o 52Framework para montagem do layout das páginas.

	O navegador utilizado para os testes da aplicação Web foi o Google Chrome 11. Os servidores utilizados para execução dos testes de performance foram máquinas virtuais Ubuntu 10.10 no Rackspace Cloud.

	Para a execução dos testes de performance, foram implementados scripts em Node.js para as duas tecnologias. Com WebSockets, foi utilizado o módulo websocket-client, enquanto que para a implementação Ajax foram utilizados os recursos HTTP nativos do Node.JS.
	

\section{Ambiente}

	Para a realização dos testes foram criadas duas máquinas virtuais no Rackspace Cloud, sendo que uma máquina foi utilizada para executar a parte servidora da aplicação, e a outra, o script de benchmark. As duas máquinas tinham a mesma configuração, sendo ela:

	\begin{itemize}
		\item Sistema Operacional: Ubuntu 10.10 (Maverick Meerkat)
		\item CPU: Quad-Core AMD Opteron(tm) Processor 2374 HE, 2,2 Ghz, 512 Cache
		\item Memória: 256 Mb
	\end{itemize}	

      Por ser uma solução de Cloud Computing, não temos algumas informações como velocidade da rede entre as duas máquinas e velocidade dos discos rígidos. Além disso, as máquinas virtuais não utilizam o poder total dos processadores. Quanto maior o plano contratado, maior o uso que se pode fazer do processador.
	
\section{Dados a serem coletados}

	Durante a execução do experimentos, dados serão coletados tanto nos clientes quanto nos servidores. Em ambos os casos os dados são coletados através de impressões na tela com padrão CSV (\textit{Comma Separated Values}) que são redirecionadas para um arquivo de texto no momento da execução.
	
	Os servidores coletam dados em intervalos de 1 em 1 segundo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,Número de usuários,Consumo de memória,Consumo de CPU,Total de mensagens,
    Número de mensagens desde o último log"
	\end{Verbatim}
	}
	
	Os clientes coletam dados a cada comunicação com o servidor, seja ela recebendo ou enviando mensagens no bate-papo e cada linha tem o seguinte formato:
	
	{\linespread{1} \scriptsize \begin{Verbatim}[frame=single]
"Timestamp,ID do usuário,Operação,Número de usuários,Tamanho da mensagem"
	\end{Verbatim}
	}
	
	Os dados relativos a entrada e saída da sala de bate-papo são desconsideradas neste experimento.

\chapter{Execução}\label{cap:execução}

	Os scripts foram executados de modo a simularem 40 clientes simultaneos, gerando uma mensagem por segundo, em um total de 200 mensagens cada. Lembrando que na aplicação Ajax, além do envio da mensagem, cada cliente fazia a requisição para novas mensagens a cada 0,5 segundo. Além disso, os 40 usuários foram inseridos a uma taxa de 1 novo usuário por segundo, até atingir os 40 usuários.

	Os experimentos foram então executados, sendo que cada um levou cerca de 4 minutos para terminarem. Os arquivos de log dos servidores e dos clientes foram coletados e utilizados para a análise dos dados e para geração dos gráficos. Foi necessário colher uma amostra dos logs dos 	clientes, já que esses geraram uma quantidade muito grande de dados, principalmente a implementação com WebSockets.


\chapter{Resultados obtidos}\label{cap:conclusao}

	texto
	
%\bibliographystyle{abnt-num}
%\bibliography{monografia}

%  \anexo
%  \chapter{Glossário}
%  Teste de apêndice


\end{document}